(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{409:function(t,n,e){"use strict";e.r(n);var s=e(5),a=Object(s.a)({},(function(){var t=this,n=t._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("p",[t._v("**一、unittest和pytest框架对比 **\n**1.unittest框架介绍 **\nUnittest是Python标准库中自带的单元测试框架，Unittest有时候也被称为PyUnit，就像\nJUnit是Java语言的标准单元测试框架一样，Unittest则是Python语言的标准单元测试框\n架。\nUnittest支持自动化测试，测试用例的初始化、关闭和测试用例的聚合等功能，它有一个很\n重要的特性：它是通过类(class)的方式，将测试用例组织在一起。\n*"),n("em",[t._v("2.pytest框架介绍 **\nPytest是Python的另一个第三方单元测试库。它的目的是让单元测试变得更容易，并且也\n能扩展到支持应用层面复杂的功能测试。\npytest的特性有：\n支持用简单的assert语句实现丰富的断言，无需复杂的self.assert"),n("em",[t._v("函数\n自动识别测试模块和测试函数\n模块化夹具用以管理各类测试资源\n对 unittest 完全兼容，对 nose基本兼容\n支持Python3和PyPy3\n丰富的插件生态，已有1118个各式各样的插件，社区繁荣\n插件链接：https://docs.pytest.org/en/latest/reference/plugin_list.html\n**3.unittest和pytest框架对比 **\n**4.pytest 安装 **\na)安装\npip install pytest\nb)验证安装\npytest --version\nc) 运行模式的配置\nd) pytest文档\n官方文档：https://docs.pytest.org/en/latest/contents.html\n3.pytest的用例运行规则\n1）pytest将在当前目录及其子目录中运行所有格式为test_")]),t._v(".py或者")]),t._v("_test.py文件\n2）测试方法/测试函数 默认必须是test开头\n3） 测试类必须是Test开头\n4） 测试类不能有构造方法 "),n("strong",[t._v("init")]),t._v("\n**二、Pytest的常用应用 **\n**1.断言pytest **\n借助Python的运算符号 和 assert关键字 来实现的。\n**2.pytest常用运行参数 **\n\"-s\" 参数 用于关闭捕捉，从而输出打印信息到控制台\n\"-v\" 参数 用于显示具体的用例执行信息‘\n通过Pytest --help 查看帮助\n1）运行名称中包含某字符串的测试用例\n-k\n2) 简化输出信息\n-q\n3) 如果出现一条测试用例失败，则退出测试\n-x\n4) 指定目录以及特定类或方法执行\npytest.main(['-s','./doc/test_112233.py::TestDemo::test_case_03'])\n**3.生成测试报告 **\n生成junit xml文件测试报告\n**4.用例失败控制 **\n在第N个很用例失败之后，结束测试执行\npytest.main(['--maxfail=2'])\n**5.通过标记表达式执行 **\npytest.main(['-m','smoke'])\n这条命令会执行被\n装饰器 @pytest.mark.smoke 装饰的所有测试用例\n先在pytest.ini 文件中注册自定义标记\n**6.多进程运行用例 **\n安装pytest-xdist:\npip install pytest-xdist")]),t._v(" "),n("h1",{attrs:{id:"将测试执行发送到多个cpu"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#将测试执行发送到多个cpu"}},[t._v("#")]),t._v(" 将测试执行发送到多个cpu")]),t._v(" "),n("h1",{attrs:{id:"pytest-main-n-2-test-many-py"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#pytest-main-n-2-test-many-py"}},[t._v("#")]),t._v(" pytest.main(['-n','2','test_many.py'])")]),t._v(" "),n("h1",{attrs:{id:"使用与计算机具有cpu内核一样多的进程"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#使用与计算机具有cpu内核一样多的进程"}},[t._v("#")]),t._v(" 使用与计算机具有cpu内核一样多的进程")]),t._v(" "),n("p",[t._v("pytest.main(['-n', 'auto', 'test_many.py'])\n**PS：最新版本的pytest和插件发现跑不起来 **\n已验证可运行版本：\npytest:6.1.2 pytest-xdist 1.31.0\n**7.重新运行失败用例 **\npytest-rerunfailures是一个可以使pytest重新运行测试的插件，以消除间歇性故障。\n安装要求：\n您需要具备以下先决条件才能使用pytest-rerunfailures：\n安装\npip install pytest-rerunfailures\nPython 3.5，最高3.8或PyPy3\npytest 5.0或更高版本\n目前已针对最近的5个次要pytest版本测试了该软件包。如果您使用的是较早版本的\npytest，则应考虑更新或使用此软件包的较早版本之一。")]),t._v(" "),n("h1",{attrs:{id:"重新运行所有测试失败用例"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#重新运行所有测试失败用例"}},[t._v("#")]),t._v(" 重新运行所有测试失败用例")]),t._v(" "),n("p",[t._v("pytest.main(['--reruns', '3', 'test_rerun.py'])")]),t._v(" "),n("h1",{attrs:{id:"在每次重跑之间-增加一次延迟时间"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#在每次重跑之间-增加一次延迟时间"}},[t._v("#")]),t._v(" 在每次重跑之间，增加一次延迟时间")]),t._v(" "),n("p",[t._v("pytest.main(['--reruns', '3','--reruns-delay','2','test_rerun.py'])\n**8.pytest的setup和teardown函数 **\n用例前置和后置\nsetup和teardown 可以在类的外面和里面使用\n**9.pytest配置文件 **\npytest.ini文件中如果有中文，可能会出编码问题，需要把文件设置为gbk\n1.选择pytest.ini文件\n2.点击 file选项\n3.选择 File Encoding后\n4.选择 GBK\n5.选择convert\n**10.pytest常用插件 **\n插件列表网址：https://docs.pytest.org/en/latest/reference/plugin_list.html\npytest-html插件\n安装：\npip install pytest-html\n使用方法： 命令行格式：pytest --html=用户路径/report.html\n**三、Pytest高阶用法之函数数据参数化 **\n单参数、多参数、函数数据参数化\n方法：\nparametrize(argnames, argvalues, indirect=False, ids=None, scope=None)\n常用参数：\nargnames：参数名\nargvalues：参数对应值，类型必须为list\n当参数为一个时格式：[value]\n当参数个数大于一个时，格式为:[(param_value1,param_value2.....),\n(param_value1,param_value2.....)]\n使用方法:\n@pytest.mark.parametrize(argnames,argvalues)\n参数值为N个，测试方法就会运行N次\n**四、Pytest之Fixture介绍 **\n官方原话：\nhttps://docs.pytest.org/en/latest/explanation/fixtures.html#about-fixtures\npytest fixtures被设计为明确的、模块化的以及可扩展的\n什么是fixtures\n在测试中，fixture为测试提供了已定义的，可靠的和一致的上下文。这可能包括环境（例\n如，通过已知的参数配置数据库）或内容（例如，数据集）。\n"),n("strong",[t._v("Fixtures定义了构成测试准备阶段的步骤和数据")]),t._v('。在pytest中，它们是为这些目的而定义的\n函数。它们也可以用来定义测试执行阶段；这是一个设计复杂用例的强大技术。\n测试功能通过参数访问由fixtures设置的服务，状态或其他操作环境。对于测试功能使用的\n每个fixture，通常在测试功能的定义中都有一个参数（在 fixture后命名）。\n**我们可以通过用修饰器@pytest.fixture来告诉pytest某个特定函数是一个fixture **。\n**五、Conftest.py **\nconftest.py是pytest特有的本地测试配置文件，既可以用力啊设置项目级的Fixture,也可以\n用来导入外部插件，还可以用来指定Hook函数（钩子函数）\nconftest.py文件名称是固定，pytest会自动识别该文件，只作用于它所在的目录及子目录\n**六、Conftest.py+fixture+yield 实现用例前置后 **\n**置 **\n通过Conftest.py+fixture+yield，可轻松实现用例前置后置，包括项目级的\n1 #coding=gbk\n2 import pytest\n3\n4 @pytest.fixture()\n5 def fix1():\n6 print("\\n开始执行fix1")\n7 yield\n8 print("\\n结束执行fix1")')])])}),[],!1,null,null,null);n.default=a.exports}}]);